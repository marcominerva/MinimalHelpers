using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MinimalHelpers.Routing.Analyzers;

[Generator]
public class EndpointRouteHandlerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the interface during post-initialization.
        context.RegisterPostInitializationOutput(static context =>
        {
            var @interface = GetIEndpointRouteHandlerBuilderInterface();
            context.AddSource("IEndpointRouteHandlerBuilder.g.cs", SourceText.From(@interface, Encoding.UTF8));
        });

        var endpointClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                transform: static (context, token) =>
                {
                    if (!context.SemanticModel.Compilation.HasLanguageVersionAtLeastEqualTo(LanguageVersion.CSharp11))
                    {
                        return null;
                    }

                    token.ThrowIfCancellationRequested();

                    var classDeclaration = (ClassDeclarationSyntax)context.Node;
                    var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration, token);

                    if (classSymbol is null)
                    {
                        return null;
                    }

                    // Check if it implements IEndpointRouteHandlerBuilder using semantic model.
                    var endpointRouteHandlerBuilderSymbol = context.SemanticModel.Compilation.GetTypeByMetadataName("Microsoft.AspNetCore.Routing.IEndpointRouteHandlerBuilder");
                    if (endpointRouteHandlerBuilderSymbol is null || !classSymbol.AllInterfaces.Contains(endpointRouteHandlerBuilderSymbol, SymbolEqualityComparer.Default))
                    {
                        return null;
                    }

                    return classSymbol;
                })
            .Where(static symbol => symbol is not null)
            .Collect();

        context.RegisterSourceOutput(endpointClasses, Execute!);
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol?> classSymbols)
    {
        //#if DEBUG
        //        if (!Debugger.IsAttached)
        //        {
        //            Debugger.Launch();
        //        }
        //#endif

        var validClasses = classSymbols.Where(static symbol => symbol is not null).Cast<INamedTypeSymbol>().ToArray();

        //if (validClasses.Length == 0)
        //{
        //    return;
        //}

        var prefixCode = """
            // <auto-generated />
            namespace Microsoft.AspNetCore.Routing;

            #nullable enable annotations
            #nullable disable warnings

            /// <summary>
            /// Provides extension methods for <see cref="IEndpointRouteBuilder" /> to add route handlers.
            /// </summary>
            public static class EndpointRouteBuilderExtensions
            {
                /// <summary>
                /// Automatically registers all the route endpoints defined in classes that implement the <see cref="IEndpointRouteHandlerBuilder "/> interface.
                /// </summary>
                /// <param name="endpoints">The <see cref="IEndpointRouteBuilder" /> to add routes to.</param>
                public static IEndpointRouteBuilder MapEndpoints(this IEndpointRouteBuilder endpoints)
                {            
            """;

        var suffixCode = """

                    return endpoints;
                }
            }
            """;

        var codeBuilder = new StringBuilder();
        codeBuilder.AppendLine(prefixCode);

        foreach (var classSymbol in validClasses)
        {
            var fullClassName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            codeBuilder.AppendLine($"        {fullClassName}.MapEndpoints(endpoints);");
        }

        codeBuilder.AppendLine(suffixCode);

        context.AddSource("EndpointRouteBuilderExtensions.g.cs", SourceText.From(codeBuilder.ToString(), Encoding.UTF8));
    }

    private static string GetIEndpointRouteHandlerBuilderInterface()
        => """
            // <auto-generated />
            namespace Microsoft.AspNetCore.Routing;

            #nullable enable annotations
            #nullable disable warnings                

            /// <summary>
            /// Defines a contract for a class that holds one or more route handlers that must be registered by the application.
            /// </summary>
            public interface IEndpointRouteHandlerBuilder
            {
                /// <summary>
                /// Maps route endpoints to the corresponding handlers.
                /// </summary>
                static abstract void MapEndpoints(IEndpointRouteBuilder endpoints);
            }
            """;
}