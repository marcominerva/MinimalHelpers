using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MinimalHelpers.Routing.Analyzers;

[Generator]
public class EndpointGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
                (node, _) => node is ClassDeclarationSyntax,
                (syntaxtContext, _) => (ClassDeclarationSyntax)syntaxtContext.Node
            ).Where(c => c is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());
        context.RegisterSourceOutput(compilation, Execute);
    }

    private void Execute(SourceProductionContext context, (Compilation Compilation, ImmutableArray<ClassDeclarationSyntax> Classes) tuple)
    {
        //#if DEBUG
        //        if (!Debugger.IsAttached)
        //        {
        //            Debugger.Launch();
        //        }
        //#endif

        var (compilation, classes) = tuple;

        var @interface = GetIEndpointRouteHandlerBuilderInterface();
        context.AddSource("IEndpointRouteHandlerBuilder.g.cs", @interface);

        var prefixCode = """
            // <auto-generated />
            namespace Microsoft.AspNetCore.Routing;

            #nullable enable annotations
            #nullable disable warnings

            public static class EndpointRouteHandlerBuilderExtensions
            {
                public static IEndpointRouteBuilder MapEndpoints(this IEndpointRouteBuilder endpoints)
                {            
            """;

        var suffixCode = """

                    return endpoints;
                }
            }
            """;

        var codeBuilder = new StringBuilder();
        codeBuilder.AppendLine(prefixCode);

        foreach (var @class in classes.Where(c => c.BaseList?.Types.Any(t => t.Type.ToString() == "IEndpointRouteHandlerBuilder") is true))
        {
            var symbol = compilation.GetSemanticModel(@class.SyntaxTree).GetDeclaredSymbol(@class) as INamedTypeSymbol;
            var fullClassName = $"{symbol!.ContainingNamespace}.{symbol.Name}".TrimStart('.');

            codeBuilder.AppendLine($"        {fullClassName}.MapEndpoints(endpoints);");
        }

        codeBuilder.AppendLine(suffixCode);

        context.AddSource("EndpointRouteHandlerBuilderExtensions.g.cs", codeBuilder.ToString());
    }

    private static string GetIEndpointRouteHandlerBuilderInterface()
        => """
                // <auto-generated />
                namespace Microsoft.AspNetCore.Routing;

                /// <summary>
                /// Defines a contract for a class that holds one or more route handlers that must be registered by the application.
                /// </summary>
                /// <seealso cref="IEndpointRouteBuilder" />
                /// <seealso cref="IEndpointRouteBuilderExtensions" />
                public interface IEndpointRouteHandlerBuilder
                {
                    /// <summary>
                    /// Maps route endpoints to the corresponding handlers.
                    /// </summary>
                    /// <param name="endpoints">The <see cref="IEndpointRouteBuilder" /> to add routes to.</param>
                    static abstract void MapEndpoints(IEndpointRouteBuilder endpoints);
                }
                """;
}
